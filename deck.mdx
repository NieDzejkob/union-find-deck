import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import { github, vsDark } from "@code-surfer/themes";
import { Animation, animateLayers, makeGraph, highlightSubtree } from "./animation.js";

export const theme = vsDark;

# Union-Find

Składowe spójne w zmieniającym się grafie.

---

<Animation
graph={makeGraph([
    [1, 2],
    [2, 3],
    [1, 5],
    [2, 5],
    [3, 4],
    [4, 5],
    [4, 6],
    [3, 9, 'shadow'],
    [9, 8],
    [8, 7],
    [4, 7, ['shadow', 'long']],
])}
steps={g => [
    // Weźmy sobie jakiś graf
    ['reset'],
    // Chcemy wiedzieć, czy między dwoma węzłami istnieje ścieżka. Na przykład,
    // jeśli weźmiemy 1 i 6,
    ['add', [['green', 1], ['green', 6]]],
    // to możemy przejść między nimi, przez 4 i 5
    ['add',
     [['blue', 1, 5],
      ['blue', 5]],
     [['blue', 5, 4],
      ['blue', 4]],
     [['blue', 4, 6]],
     ],
    // Lecz jeśli weźmiemy sobie 6 i 9, to nie ma między nimi ścieżki.
    ['reset', [['red', 6], ['red', 9]]],
    // Jak możemy odpowiedzieć na to pytanie?
    ['reset'],
    // Moglibyśmy zrobić tak, że weźmiemy jeden z końców...
    ['add', [['green', 1]]],
    // i puścimy wyszukiwanie, w głąb lub wszerz, nie ma znaczania
    ['add'].concat(animateLayers(g, 1, 'blue', 3, 'green')),
    // Takie podejście będzie miało złożoność n + k, gdzie n to liczba wierzchołków,
    // k to liczba krawędzi, z tym że każde zapytanie
    // zaczynamy od zera, więc pomnożymy to jeszcze przez q.
    ['setComment', 'O(q(n + k))'],
    // Możemy to zrobić lepiej - weźmy puśćmy wyszukiwanie z każdego wierzchołka po kolei,
    // i ponumerujmy spójne składowe.
    ['reset', [['blue', 1]]].concat(animateLayers(g, 1, 'blue')),
    ['add', [['orange', 7]]].concat(animateLayers(g, 7, 'orange')),
    // Teraz jak dostaniemy jakąś parę wierzchołków do sprawdzenia, to wystarczy
    // sprawdzić czy są w tej samej spójnej składowej - na rysunku,
    // czy są tego samego koloru.
    //
    // Jaka jest złożoność tego rozwiązania? Jak jakiś wierzchołek już jest pokolorowany,
    // to nie musimy z niego puszczać kolejnego przeszukiwania, więc przygotowania zajmą
    // nam O(n + k), po czym na każde zapytanie odpowiemy w czasie stałym.
    ['setComment', 'O(n + k + q)'],
    // Takie podejście ma taką wadę, że naszego grafu nie możemy za bardzo zmieniać.
    ['reset'],
    // Struktura danych Union-Find odpowiada na to samo pytanie,
    // ale pozwala nam na szybkie dodanie krawędzi do grafu.
    ['reset', [['white', 3, 9, 'dashed']]],
    // Union-Find przypisuje każdej spójnej składowej pewnego reprezentanta.
    // Jest to po prostu wyróżniony wierzchołek grafu.
    ['reset', [['blue', 4], ['blue', 8]]],
    ['setComment', "Find\nO(log n)",
     'add', [
         ['orange', 2], ['orange', 2, 4, 'arrow'],
         ['orange', 1], ['orange', 1, 4, 'arrow'],
         ['orange', 3], ['orange', 3, 4, 'arrow'],
         ['orange', 7], ['orange', 7, 8, 'arrow'],
        ]],
    ['setComment', 'Union\nO(log n)',
     'replace', [['red', 3, 9]]],
    ['add', [['white', 8]]],
]} />

---

<div style={{display: "flex", flexDirection: "row", width: "100%", height: "100%"}}>

<div style={{display: "block", height: "100%", width: "50%"}}>
<Animation
graph={makeGraph([
    [1, 2],
    [2, 3],
    [1, 5],
    [2, 5],
    [3, 4],
    [4, 5],
    [4, 6],
    [3, 9, 'shadow'],
    [9, 8],
    [8, 7],
    [4, 7, ['shadow', 'long']],
])}
steps={g => [
    ['reset'],
    ['reset', [['blue', 4], ['blue', 8]]],
    ['add'],
    ['setComment', 'Find\u00a0\u00a0\u00a0',
     'add', [['orange', 2], ['orange', 2, 4, 'arrow']]],
    ['setComment', 'Union\u00a0\u00a0\u00a0',
     'replace', [['red', 3, 9]]],
    ['add', [['orange', 3], ['orange', 3, 4, 'arrow'],
             ['orange', 9], ['orange', 9, 8, 'arrow']]],
    ['add', [['white', 8]]],
]} />
</div>

<div style={{display: "block", height: "100%", width: "50%", background: "#f6f8fa"}}>
<Animation color="black" directed
graph={makeGraph([
    [1, 4],
    [5, 4],
    [6, 4],
    [2, 6],
    [3, 5],
    [7, 8],
    [9, 8],
    [8, 4, ['shadow', 'long']],
], [4, 8])}
steps={g => [
    // Union Find ma strukturę lasu drzew. Każde drzewo odpowiada składowej spójnej
    // w grafie.
    ['reset'],
    // Korzenie są reprezentantami składowych. Poza tym, drzewo nie odzwierciedla
    // w żaden sposób struktury grafu. Każdy wierzchołek pamięta, kto jest jego rodzicem.
    ['reset', [['blue', 4], ['blue', 8]]],
    // Konwencja jest taka, że reprezentanci są swoimi własnymi rodzicami.
    ['add', [['black', 4, 4, 'arrow'],
             ['black', 8, 8, 'arrow']]],
    // Find jest wtedy dość prosty - po prostu idziemy w górę, aż trafimy na pętlę,
    // która oznacza reprezentanta.
    ['add', [['orange', 2], ['orange', 2, 6, 'arrow']],
            [['orange', 6], ['orange', 6, 4, 'arrow']]],
    // Union jest trochę bardziej skomplikowany. Załóżmy dla przykładu, że chcemy dodać
    // krawędź pomiędzy 3 a 9.
    ['replace'],
    // Najpierw musimy znaleźć reprezentantów za pomocą Finda - liczy się to,
    // które składowe są łączone, nie w którym miejscu.
    ['add',
        [['orange', 3], ['orange', 3, 5, 'arrow'], ['orange', 9], ['orange', 9, 8, 'arrow']],
        [['orange', 5], ['orange', 5, 4, 'arrow']]
    ],
    // Następnie łączymy ze sobą reprezentantów.
    // Ważne jest to, aby dzieckiem została ta składowa, która oryginalnie miała
    // mniej wierzchołków.
    ['reset', [['red', 8, 4, 'arrow'], ['blue', 4], ['blue', 8],
        ['black', 4, 4, 'arrow'], ['black', 8],
        ['orange', 3], ['orange', 3, 5, 'arrow'], ['orange', 9], ['orange', 9, 8, 'arrow'],
        ['orange', 5], ['orange', 5, 4, 'arrow']]
    ],
]} />

</div>
</div>

---

<Animation directed
graph={makeGraph([
    [2, 1],
    [3, 1],
    [6, 2],
    [5, 2],
    [4, 2],
    [8, 3],
    [7, 3],
    [10, 4],
    [9, 4],
    [11, 5],
    [12, 5],
    [14, 6],
    [13, 6],
    [17, 8],
    [18, 8],
    [15, 7],
    [16, 7],
], [1], 0.6)}
steps={g => [
    // Ma to duży wpływ na złożoność czasową, ponieważ nadaje drzewu taką właściwość:
    ['reset', [['white', 1, 1, 'arrow']]],
    // Że jak weźmiemy dowolne podrzewo, powiedzmy że to o korzeniu 2.
    ['add', [['red', 2]]],
    // to każde jego poddrzewo będzie miało co najwyżej połowę wierzchołków.
    ['add',
        highlightSubtree(g, 2, 4, 'orange'),
        highlightSubtree(g, 2, 5, 'yellow'),
        highlightSubtree(g, 2, 6, 'green'),
    ],
    // Dzięki temu każdy krok w dół sprawia że poddrzewo pod nami się zmniejsza o połowę,
    // przez co wysokość drzewa to około logarytm z n.
]} />

---
<CodeSurfer>

```js title="This is a title" subtitle="and this a subtitle"
function lorem(ipsum, dolor = 1) {
  const sit = ipsum == null ? 0 : ipsum.sit;
  dolor = sit - amet(dolor);
  return sit
    ? consectetur(ipsum, 0, dolor < 0 ? 0 : dolor)
    : [];
}

function incididunt(ipsum, ut = 1) {
  ut = labore.et(amet(ut), 0);
  const sit = ipsum == null ? 0 : ipsum.sit;

  if (!sit || ut < 1) {
    return [];
  }

  let dolore = 0;
  let magna = 0;
  const aliqua = new eiusmod(labore.ut(sit / ut));

  while (dolore < sit) {
    aliqua[magna++] = consectetur(
      ipsum,
      dolore,
      (dolore += ut)
    );
  }

  return aliqua;
}
```

```js
function lorem(ipsum, dolor = 1) {
  const sit = ipsum == null ? 0 : ipsum.sit;
  dolor = sit - amet(dolor);
  return sit
    ? consectetur(ipsum, 0, dolor < 0 ? 0 : dolor)
    : [];
}

function adipiscing(...elit) {
  if (!elit.sit) {
    return [];
  }

  const sed = elit[0];
  return eiusmod.tempor(sed) ? sed : [sed];
}

function incididunt(ipsum, ut = 1) {
  ut = labore.et(amet(ut), 0);
  const sit = ipsum == null ? 0 : ipsum.sit;

  if (!sit || ut < 1) {
    return [];
  }

  let dolore = 0;
  let magna = 0;
  const aliqua = new eiusmod(labore.ut(sit / ut));

  while (dolore < sit) {
    aliqua[magna++] = consectetur(
      ipsum,
      dolore,
      (dolore += ut)
    );
  }

  return aliqua;
}
```

```diff 1[10:14],2[15:19],3[22:27],10:12

```

</CodeSurfer>

---

<CodeSurferColumns themes={[vsDark, github]}>

<Step>

```js
const magna = aliqua => aliqua.ut((enim, ad) => enim, 0);
```

```js
const minim = (ad, enim) => dolore.magna(ad / enim);
```

</Step>

<Step>

```js
const lorem = (ipsum, dolor, sit) => {
  const amet = dolor - ipsum;
  return consectetur.adipiscing(
    {
      elit: sed.eiusmod(sit - dolor) / amet + 2,
    },
    (tempor, incididunt) => ipsum + amet * incididunt
  );
};

const magna = aliqua => aliqua.ut((enim, ad) => enim, 0);
```

```js
const minim = (ad, enim) => dolore.magna(ad / enim);

const sed = (eiusmod, tempor, incididunt) => {
  const ut = tempor - eiusmod;
  return labore.et(
    {
      amet: dolore.magna(incididunt - tempor) / ut + 2,
    },
    (aliqua, elit) => eiusmod + ut * elit
  );
};
```

</Step>

</CodeSurferColumns>

---

docs:  
[codesurfer.pomb.us](https://codesurfer.pomb.us)
